# -*- coding: utf-8 -*-
"""Copy of CodeMix.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_u6RKwyEUDn4iHN5LF-pFZQKSJ7vnlyv
"""

!pip install -U -q PyDrive
from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

downloaded = drive.CreateFile({'id':'17wonYk5t2MJuJ-qv_vFbnX0f24Z-c-7A'})
downloaded.GetContentFile('original_dataset.csv')

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
from sklearn.preprocessing import LabelEncoder

df_train = pd.read_csv(r'original_dataset.csv')

# Mapping categorical labels to integers
label_dict = {'Not_offensive': 0, 'Offensive': 1}
df_train['offensive_label'] = df_train['offensive_label'].map(label_dict)

# Fill NaN values with -1
df_train['offensive_label'] = df_train['offensive_label'].fillna(-1).astype(int)

label_list_train = list(df_train['offensive_label'])
word_list_train = list(df_train['codemix_text'])

# Printing for verification
print(word_list_train)
print(label_list_train)

from sklearn.linear_model import SGDClassifier
from sklearn.pipeline import Pipeline
from sklearn.feature_extraction.text import TfidfTransformer, CountVectorizer
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.model_selection import train_test_split
import pandas as pd

translated_csv_path = 'original_dataset.csv'
df = pd.read_csv(translated_csv_path)

df.fillna('', inplace=True)

train_data, test_data = train_test_split(df, test_size=0.2, random_state=42)

train_texts = train_data['codemix_text'].values.astype('U')
train_labels = train_data['offensive_label'].values

test_texts = test_data['codemix_text'].values.astype('U')
test_labels = test_data['offensive_label'].values

sgd = Pipeline([
    ('vect', CountVectorizer(ngram_range=(1, 2), min_df=1)),
    ('tfidf', TfidfTransformer(sublinear_tf=True)),
    ('clf', SGDClassifier(loss='hinge', penalty='l2', alpha=1e-4, random_state=42, max_iter=20, tol=1e-3)),
])

sgd.fit(train_texts, train_labels)

y_pred = sgd.predict(test_texts)

print('accuracy %s' % accuracy_score(test_labels, y_pred))
print(classification_report(test_labels, y_pred))

print('Confusion Matrix:')
print(confusion_matrix(test_labels, y_pred))

from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report,confusion_matrix

# Assuming you have your data loaded into 'df' and 'column_to_predict' represents the column with labels
translated_csv_path = 'original_dataset.csv'
df = pd.read_csv(translated_csv_path)

df.fillna('', inplace=True)


train_data, test_data = train_test_split(df, test_size=0.2, random_state=42)

train_texts = train_data['codemix_text'].values.astype('U')
train_labels = train_data['offensive_label'].values

test_texts = test_data['codemix_text'].values.astype('U')
test_labels = test_data['offensive_label'].values

logreg = Pipeline([
    ('vect', CountVectorizer(ngram_range=(1, 3), min_df=1)),
    ('tfidf', TfidfTransformer(sublinear_tf=True)),
    ('clf', LogisticRegression(n_jobs=1, C=1e3)),
])

logreg.fit(train_texts, train_labels)

y_pred = logreg.predict(test_texts)

print('accuracy %s' % accuracy_score(y_pred, test_labels))
print(classification_report(test_labels, y_pred))

print('Confusion Matrix:')
print(confusion_matrix(test_labels, y_pred))

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer
from sklearn.pipeline import Pipeline
from sklearn.model_selection import train_test_split
import pandas as pd

# Load the translated dataset
translated_csv_path = 'original_dataset.csv'
df = pd.read_csv(translated_csv_path)

df.fillna('', inplace=True)

train_data, test_data = train_test_split(df, test_size=0.2, random_state=42)

train_texts = train_data['codemix_text'].values.astype('U')
train_labels = train_data['offensive_label'].values

test_texts = test_data['codemix_text'].values.astype('U')
test_labels = test_data['offensive_label'].values

rf = Pipeline([
    ('vect', CountVectorizer(ngram_range=(1, 3), min_df=1)),
    ('tfidf', TfidfTransformer(sublinear_tf=True)),
    ('clf', RandomForestClassifier(max_depth=10, random_state=65)),
])

rf.fit(train_texts, train_labels)

y_pred = rf.predict(test_texts)

print('Accuracy:', accuracy_score(test_labels, y_pred))
print(classification_report(test_labels, y_pred))

print('Confusion Matrix:')
print(confusion_matrix(test_labels, y_pred))

from sklearn.svm import SVC
from sklearn.pipeline import Pipeline
from sklearn.feature_extraction.text import TfidfTransformer, CountVectorizer
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.model_selection import train_test_split
import pandas as pd

# Load the translated dataset
translated_csv_path = 'original_dataset.csv'
df = pd.read_csv(translated_csv_path)

df.fillna('', inplace=True)

train_data, test_data = train_test_split(df, test_size=0.2, random_state=42)

train_texts = train_data['codemix_text'].values.astype('U')
train_labels = train_data['offensive_label'].values

test_texts = test_data['codemix_text'].values.astype('U')
test_labels = test_data['offensive_label'].values

# SVM classifier pipeline with CountVectorizer and TfidfTransformer for text data
svm_sigmoid = Pipeline([
    ('vect', CountVectorizer(ngram_range=(1, 4), min_df=1)),
    ('tfidf', TfidfTransformer(sublinear_tf=True)),
    ('clf', SVC(kernel='sigmoid'))  # Using a sigmoid kernel
])

# Train the SVM model
svm_sigmoid.fit(train_texts, train_labels)

# Predict on the test set
y_pred = svm_sigmoid.predict(test_texts)

# Evaluate the model
print('Accuracy:', accuracy_score(test_labels, y_pred))
print(classification_report(test_labels, y_pred))

print('Confusion Matrix:')
print(confusion_matrix(test_labels, y_pred))

from sklearn.svm import SVC
from sklearn.pipeline import Pipeline
from sklearn.feature_extraction.text import TfidfTransformer, CountVectorizer
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.model_selection import train_test_split
import pandas as pd

# Load the translated dataset
translated_csv_path = 'original_dataset.csv'
df = pd.read_csv(translated_csv_path)

df.fillna('', inplace=True)

# Split the dataset into 80-20 ratio for training and testing
train_data, test_data = train_test_split(df, test_size=0.2, random_state=42)

train_texts = train_data['codemix_text'].values.astype('U')
train_labels = train_data['offensive_label'].values

test_texts = test_data['codemix_text'].values.astype('U')
test_labels = test_data['offensive_label'].values

# SVM classifier pipeline with CountVectorizer and TfidfTransformer for text data
svm_poly = Pipeline([
    ('vect', CountVectorizer(ngram_range=(1, 4), min_df=1)),
    ('tfidf', TfidfTransformer(sublinear_tf=True)),
    ('clf', SVC(kernel='poly', degree=3))  # Using a polynomial kernel with degree 3
])

# Train the SVM model
svm_poly.fit(train_texts, train_labels)

# Predict on the test set
y_pred = svm_poly.predict(test_texts)

# Evaluate the model
print('Accuracy:', accuracy_score(test_labels, y_pred))
print(classification_report(test_labels, y_pred))

print('Confusion Matrix:')
print(confusion_matrix(test_labels, y_pred))

from sklearn.svm import SVC
from sklearn.pipeline import Pipeline
from sklearn.feature_extraction.text import TfidfTransformer, CountVectorizer
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.model_selection import train_test_split
import pandas as pd

# Load the translated dataset
translated_csv_path = 'original_dataset.csv'
df = pd.read_csv(translated_csv_path)


df.fillna('', inplace=True)

# Assuming 'df' contains the translated dataset and 'Offensivelabel' is the column with labels
train_data, test_data = train_test_split(df, test_size=0.2, random_state=42)

train_texts = train_data['codemix_text'].values.astype('U')
train_labels = train_data['offensive_label'].values

test_texts = test_data['codemix_text'].values.astype('U')
test_labels = test_data['offensive_label'].values

# SVM classifier pipeline with CountVectorizer and TfidfTransformer for text data
svm_linear = Pipeline([
    ('vect', CountVectorizer(ngram_range=(1, 4), min_df=1)),
    ('tfidf', TfidfTransformer(sublinear_tf=True)),
    ('clf', SVC(kernel='linear'))  # Using a linear kernel
])

# Train the SVM model
svm_linear.fit(train_texts, train_labels)

# Predict on the test set
y_pred = svm_linear.predict(test_texts)

# Evaluate the model
print('Accuracy:', accuracy_score(test_labels, y_pred))
print(classification_report(test_labels, y_pred))

print('Confusion Matrix:')
print(confusion_matrix(test_labels, y_pred))

from sklearn.naive_bayes import MultinomialNB
from sklearn.pipeline import Pipeline
from sklearn.feature_extraction.text import TfidfTransformer, CountVectorizer
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.model_selection import train_test_split
import pandas as pd

# Load the translated dataset
translated_csv_path = 'original_dataset.csv'
df = pd.read_csv(translated_csv_path)

df.fillna('', inplace=True)


train_data, test_data = train_test_split(df, test_size=0.2, random_state=42)

train_texts = train_data['codemix_text'].values.astype('U')
train_labels = train_data['offensive_label'].values

test_texts = test_data['codemix_text'].values.astype('U')
test_labels = test_data['offensive_label'].values

nb = Pipeline([
    ('vect', CountVectorizer(ngram_range=(1, 4), min_df=1)),
    ('tfidf', TfidfTransformer(sublinear_tf=True)),
    ('clf', MultinomialNB()),
])

nb.fit(train_texts, train_labels)

y_pred = nb.predict(test_texts)

print('Accuracy:', accuracy_score(test_labels, y_pred))
print(classification_report(test_labels, y_pred))

print('Confusion Matrix:')
print(confusion_matrix(test_labels, y_pred))

from transformers import BertTokenizer, BertForSequenceClassification, AdamW

model_name = 'bert-base-uncased'
tokenizer = BertTokenizer.from_pretrained(model_name)
model = BertForSequenceClassification.from_pretrained(
    model_name,
    num_labels=len(set(translated_df['offensive_label'])),
    output_attentions=False,
    output_hidden_states=False
)

# Tokenize text data
max_length = 128  # You can adjust this value based on your text length distribution
train_encodings = tokenizer(train_texts.tolist(), truncation=True, padding=True, max_length=max_length)
val_encodings = tokenizer(val_texts.tolist(), truncation=True, padding=True, max_length=max_length)

# Create TensorDataset for train and validation sets
train_dataset = TensorDataset(
    torch.tensor(train_encodings['input_ids']),
    torch.tensor(train_encodings['attention_mask']),
    torch.tensor(train_labels)
)
val_dataset = TensorDataset(
    torch.tensor(val_encodings['input_ids']),
    torch.tensor(val_encodings['attention_mask']),
    torch.tensor(val_labels)
)

# Define batch size and create DataLoaders
batch_size = 16
train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False)

# Define optimizer and learning rate
optimizer = AdamW(model.parameters(), lr=2e-5)

# Training loop
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model.to(device)
epochs = 3  # You can adjust the number of epochs
for epoch in range(epochs):
    model.train()
    total_loss = 0
    for batch in train_loader:
        input_ids, attention_mask, labels = batch
        input_ids, attention_mask, labels = input_ids.to(device), attention_mask.to(device), labels.to(device)

        optimizer.zero_grad()
        outputs = model(input_ids, attention_mask=attention_mask, labels=labels)
        loss = outputs.loss
        total_loss += loss.item()
        loss.backward()
        optimizer.step()

    avg_train_loss = total_loss / len(train_loader)

    # Validation loop
    model.eval()
    val_preds = []
    val_true = []
    for batch in val_loader:
        input_ids, attention_mask, labels = batch
        input_ids, attention_mask, labels = input_ids.to(device), attention_mask.to(device), labels.to(device)

        with torch.no_grad():
            outputs = model(input_ids, attention_mask=attention_mask)
            logits = outputs.logits

        val_preds.extend(torch.argmax(logits, axis=1).cpu().numpy())
        val_true.extend(labels.cpu().numpy())

def predict_offensiveness(input_text, trained_model):
    # Make a prediction using the trained model
    predicted_label = trained_model.predict([input_text])[0]
    return predicted_label

# Assuming `svm_linear` is your trained SVM model
user_input = input("Enter your text: ")

# Call the prediction function
result = predict_offensiveness(user_input, svm_linear)

# Mapping predicted labels to their corresponding meanings
label_meanings = {
    'Offensive': 'This text is offensive.',
    'Not_offensive': 'This text is not offensive.',
    'not-Kannada': 'This text is not in Kannada.'
}

# Display the predicted result
if result in label_meanings:
    print(label_meanings[result])
else:
    print("Label not recognized.")

def predict_offensiveness(input_text, trained_model):
    # Make a prediction using the trained model
    predicted_label = trained_model.predict([input_text])[0]
    return predicted_label

# Assuming `svm_linear` is your trained SVM model
user_input = input("Enter your text: ")

# Call the prediction function
result = predict_offensiveness(user_input, svm_linear)

# Mapping predicted labels to their corresponding meanings
label_meanings = {
    'Offensive': 'This text is offensive.',
    'Not_offensive': 'This text is not offensive.',
    'not-Kannada': 'This text is not in Kannada.'
}

# Display the predicted result
if result in label_meanings:
    print(label_meanings[result])
else:
    print("Label not recognized.")

def predict_offensiveness(input_text, trained_model):
    # Make a prediction using the trained model
    predicted_label = trained_model.predict([input_text])[0]
    return predicted_label

# Assuming `svm_linear` is your trained SVM model
user_input = input("Enter your text: ")

# Call the prediction function
result = predict_offensiveness(user_input, svm_linear)

# Mapping predicted labels to their corresponding meanings
label_meanings = {
    'Offensive': 'This text is offensive.',
    'Not_offensive': 'This text is not offensive.',
    'not-Kannada': 'This text is not in Kannada.'
}

# Display the predicted result
if result in label_meanings:
    print(label_meanings[result])
else:
    print("Label not recognized.")

def predict_offensiveness(input_text, trained_model):
    # Make a prediction using the trained model
    predicted_label = trained_model.predict([input_text])[0]
    return predicted_label

# Assuming `svm_linear` is your trained SVM model
user_input = input("Enter your text: ")

# Call the prediction function
result = predict_offensiveness(user_input, svm_linear)

# Mapping predicted labels to their corresponding meanings
label_meanings = {
    'Offensive': 'This text is offensive.',
    'Not_offensive': 'This text is not offensive.',
    'not-Kannada': 'This text is not in Kannada.'
}

# Display the predicted result
if result in label_meanings:
    print(label_meanings[result])
else:
    print("Label not recognized.")

def predict_offensiveness(input_text, trained_model):
    # Make a prediction using the trained model
    predicted_label = trained_model.predict([input_text])[0]
    return predicted_label

# Assuming `svm_linear` is your trained SVM model
user_input = input("Enter your text: ")

# Call the prediction function
result = predict_offensiveness(user_input, svm_linear)

# Mapping predicted labels to their corresponding meanings
label_meanings = {
    'Offensive': 'This text is offensive.',
    'Not_offensive': 'This text is not offensive.',
    'not-Kannada': 'This text is not in Kannada.'
}

# Display the predicted result
if result in label_meanings:
    print(label_meanings[result])
else:
    print("Label not recognized.")

def predict_offensiveness(input_text, trained_model):
    # Make a prediction using the trained model
    predicted_label = trained_model.predict([input_text])[0]
    return predicted_label

# Assuming `svm_linear` is your trained SVM model
user_input = input("Enter your text: ")

# Call the prediction function
result = predict_offensiveness(user_input, svm_linear)

# Mapping predicted labels to their corresponding meanings
label_meanings = {
    'Offensive': 'This text is offensive.',
    'Not_offensive': 'This text is not offensive.',
    'not-Kannada': 'This text is not in Kannada.'
}

# Display the predicted result
if result in label_meanings:
    print(label_meanings[result])
else:
    print("Label not recognized.")

def predict_offensiveness(input_text, trained_model):
    # Make a prediction using the trained model
    predicted_label = trained_model.predict([input_text])[0]
    return predicted_label

# Assuming `svm_linear` is your trained SVM model
user_input = input("Enter your text: ")

# Call the prediction function
result = predict_offensiveness(user_input, svm_linear)

# Mapping predicted labels to their corresponding meanings
label_meanings = {
    'Offensive': 'This text is offensive.',
    'Not_offensive': 'This text is not offensive.',
    'not-Kannada': 'This text is not in Kannada.'
}

# Display the predicted result
if result in label_meanings:
    print(label_meanings[result])
else:
    print("Label not recognized.")

def predict_offensiveness(input_text, trained_model):
    # Make a prediction using the trained model
    predicted_label = trained_model.predict([input_text])[0]
    return predicted_label

# Assuming `svm_linear` is your trained SVM model
user_input = input("Enter your text: ")

# Call the prediction function
result = predict_offensiveness(user_input, svm_linear)

# Mapping predicted labels to their corresponding meanings
label_meanings = {
    'Offensive': 'This text is offensive.',
    'Not_offensive': 'This text is not offensive.',
    'not-Kannada': 'This text is not in Kannada.'
}

# Display the predicted result
if result in label_meanings:
    print(label_meanings[result])
else:
    print("Label not recognized.")

def predict_offensiveness(input_text, trained_model):
    # Make a prediction using the trained model
    predicted_label = trained_model.predict([input_text])[0]
    return predicted_label

# Assuming `svm_linear` is your trained SVM model
user_input = input("Enter your text: ")

# Call the prediction function
result = predict_offensiveness(user_input, svm_linear)

# Mapping predicted labels to their corresponding meanings
label_meanings = {
    'Offensive': 'This text is offensive.',
    'Not_offensive': 'This text is not offensive.',
    'not-Kannada': 'This text is not in Kannada.'
}

# Display the predicted result
if result in label_meanings:
    print(label_meanings[result])
else:
    print("Label not recognized.")

def predict_offensiveness(input_text, trained_model):
    # Make a prediction using the trained model
    predicted_label = trained_model.predict([input_text])[0]
    return predicted_label

# Assuming `svm_linear` is your trained SVM model
user_input = input("Enter your text: ")

# Call the prediction function
result = predict_offensiveness(user_input, svm_linear)

# Mapping predicted labels to their corresponding meanings
label_meanings = {
    'Offensive': 'This text is offensive.',
    'Not_offensive': 'This text is not offensive.',
    'not-Kannada': 'This text is not in Kannada.'
}

# Display the predicted result
if result in label_meanings:
    print(label_meanings[result])
else:
    print("Label not recognized.")
